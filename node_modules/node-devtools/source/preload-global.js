(function() {
	var log = console.log.bind(console);
	var dir = console.dir.bind(console);

	var path = require('path');

	try {
		var remote = require('electron').remote;
		if (remote === undefined) throw new Error();
	} catch (e) {
		var remote = require('remote');
	}

	var sharedData = remote.getGlobal('sharedData');

	// get the entry file and its directory
	var filename = sharedData.jsFile;
	var dirname = sharedData.jsPath;

	// override specific variables
	global.__filename = filename;
	global.__dirname = dirname;

	// shim process
	process.chdir(dirname);
	var base_args = [sharedData.nodePath];
	if (!sharedData.repl) base_args.push(filename);
	process.argv = base_args.concat(sharedData.args_part2);
	process.execArgv = [].concat(sharedData.args_part1);
	process.execPath = sharedData.nodePath;
	process.devtools = true;

	var Module = require('module');
	var module = global.module;

	module.filename = filename;

	// guarantee the main module can load local modules correctly
	var version = + process.versions.node.match(/^\d+/)[0];
	if (version >= 6) {
		// 'node_modules' character codes reversed
		var nmChars = [ 115, 101, 108, 117, 100, 111, 109, 95, 101, 100, 111, 110 ];
		var nmLen = nmChars.length;
		if (process.platform === 'win32') {
			// 'from' is the __dirname of the module.
			Module._nodeModulePaths = function(from) {
				// guarantee that 'from' is absolute.
				from = path.resolve(from);

				// note: this approach *only* works when the path is guaranteed
				// to be absolute.  Doing a fully-edge-case-correct path.split
				// that works on both Windows and Posix is non-trivial.

				// return root node_modules when path is 'D:\\'.
				// path.resolve will make sure from.length >=3 in Windows.
				if (from.charCodeAt(from.length - 1) === 92/*\*/ &&
						from.charCodeAt(from.length - 2) === 58/*:*/)
					return [from + 'node_modules'];

				const paths = [];
				var p = 0;
				var last = from.length;
				for (var i = from.length - 1; i >= 0; --i) {
					const code = from.charCodeAt(i);
					// The path segment separator check ('\' and '/') was used to get
					// node_modules path for every path segment.
					// Use colon as an extra condition since we can get node_modules
					// path for dirver root like 'C:\node_modules' and don't need to
					// parse driver name.
					if (code === 92/*\*/ || code === 47/*/*/ || code === 58/*:*/) {
						if (p !== nmLen)
							paths.push(from.slice(0, last) + '\\node_modules');
						last = i;
						p = 0;
					} else if (p !== -1) {
						if (nmChars[p] === code) {
							++p;
						} else {
							p = -1;
						}
					}
				}

				return paths;
			};
		} else { // posix
			// 'from' is the __dirname of the module.
			Module._nodeModulePaths = function(from) {
				// guarantee that 'from' is absolute.
				from = path.resolve(from);
				// Return early not only to avoid unnecessary work, but to *avoid* returning
				// an array of two items for a root: [ '//node_modules', '/node_modules' ]
				if (from === '/')
					return ['/node_modules'];

				// note: this approach *only* works when the path is guaranteed
				// to be absolute.  Doing a fully-edge-case-correct path.split
				// that works on both Windows and Posix is non-trivial.
				const paths = [];
				var p = 0;
				var last = from.length;
				for (var i = from.length - 1; i >= 0; --i) {
					const code = from.charCodeAt(i);
					if (code === 47/*/*/) {
						if (p !== nmLen)
							paths.push(from.slice(0, last) + '/node_modules');
						last = i;
						p = 0;
					} else if (p !== -1) {
						if (nmChars[p] === code) {
							++p;
						} else {
							p = -1;
						}
					}
				}

				// Append /node_modules to handle root paths.
				paths.push('/node_modules');

				return paths;
			};
		}
	} else {
		// 'from' is the __dirname of the module.
		Module._nodeModulePaths = function(from) {
			// guarantee that 'from' is absolute.
			from = path.resolve(from);

			// note: this approach *only* works when the path is guaranteed
			// to be absolute.  Doing a fully-edge-case-correct path.split
			// that works on both Windows and Posix is non-trivial.
			var splitRe = process.platform === 'win32' ? /[\/\\]/ : /\//;
			var paths = [];
			var parts = from.split(splitRe);

			for (var tip = parts.length - 1; tip >= 0; tip--) {
				// don't search in .../node_modules/node_modules
				if (parts[tip] === 'node_modules') continue;
				var dir = parts.slice(0, tip + 1).concat('node_modules').join(path.sep);
				paths.push(dir);
			}

			return paths;
		};
	}

	module.paths = Module._nodeModulePaths(dirname);

	// support loading global installed modules
	var NODE_PATH_RAW = [];
	var NODE_PATH = [];
	var env = process.env;
	if (env['NODE_PATH']) NODE_PATH_RAW = env['NODE_PATH'].split(path.delimiter);
	for (var i = 0; i < NODE_PATH_RAW.length; i ++) {
		var node_path = NODE_PATH_RAW[i];
		if (node_path !== '') NODE_PATH.push(path.normalize(node_path));
	}

	var _resolveLookupPaths = Module._resolveLookupPaths;
	Module._resolveLookupPaths = function(request, parent) {
		var ret = _resolveLookupPaths(request, parent);
		var name = ret[0];
		var paths = ret[1];
		paths.push.apply(paths, NODE_PATH);
		return [name, paths];
	};

	// rewrite require, make it can load relative module correctly
	var _require = global.require;
	global.require = function() {
		var mod = arguments[0];
		if (/^\.+[\/\\]/.test(mod)) {
			return _require(path.resolve(mod));
		} else {
			return _require(mod);
		}
	};

	for (var key in _require) {
		if (_require.hasOwnProperty(key)) {
			global.require[key] = _require[key];
		}
	}

	document.addEventListener('DOMContentLoaded', function() {
		global.exports = module.exports;
		if (sharedData.reserve !== true) {
			var windowKeys = Object.getOwnPropertyNames(global);
			var nodeKeys = sharedData.nodeKeys;
			var reservedKeys = [
				'__filename',
				'__dirname',
				'module',
				'exports',
				'require'
			];

			if (sharedData.reserve !== false) {
				reservedKeys.push.apply(reservedKeys, sharedData.reserve);
			}

			windowKeys.forEach(function(key) {
				if (nodeKeys.indexOf(key) < 0 && reservedKeys.indexOf(key) < 0) {
					delete global[key];
				}
			});
		}

		// load entry script
		if (!sharedData.repl) {
			var script = document.createElement('script');
			script.type = 'text/javascript';
			script.src = filename;
			document.head.appendChild(script);
		}
	});
})();